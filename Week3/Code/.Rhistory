# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers
getwd
getwd()
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
setwd(Documents/CMEECourseWork/Week3/Code)
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
setwd(amisha/Documents/CMEECourseWork/Week3/Code)
?setwd
getwd()
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
setwd(/Documents/CMEECourseWork/Week3/Code)
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
setwd(:/Documents/CMEECourseWork/Week3/Code)
setwd("~/Documents/CMEECourseWork/Week3/Code")
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
setwd("~/Documents/CMEECourseWork/Week3/Code")
MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers
View(MyData)
write.csv(MyData, "../Desults/MyData.csv") #write it out as a new file
write.csv(MyData, "../Results/MyData.csv") #write it out as a new file
write.table(MyData[1,], file = "../Results/MyData.csv",append=TRUE) # Append to it
write.csv(MyData, "../Results/MyData.csv", row.names=TRUE) # write row names
write.table(MyData, "../Results/MyData.csv", col.names=FALSE) # ignore column names
View(MyData)
source("basic_io.R")
source("basic_io.R")
a <- TRUE
if (a == TRUE){
print ("a is TRUE")
} else {
print ("a is FALSE")
}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
#for loops
for (i in 1:10){
j <- i * i
print(paste(i, " squared is", j ))
}
#for loops
for (i in 1:10){
j <- i * i
print(i, " squared is", j )
}
for(species in c('Heliodoxa rubinoides',
'Boissonneaua jardini',
'Sula nebouxii')){
print(paste('The species is', species))
}
v1 <- c("a","bc","def")
for (i in v1){
print(i)
}
#while loops
i <- 0
while (i < 10){
i <- i+1
print(i^2)
}
#if statements
a <- TRUE
if (a == TRUE){
print ("a is TRUE")
} else {
print ("a is FALSE")
}
z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}
#for loops
for (i in 1:10){
j <- i * i
print(paste(i, " squared is", j ))
}
for(species in c('Heliodoxa rubinoides',
'Boissonneaua jardini',
'Sula nebouxii')){
print(paste('The species is', species))
}
v1 <- c("a","bc","def")
for (i in v1){
print(i)
}
#while loops
i <- 0
while (i < 10){
i <- i+1
print(i^2)
}
#breaking out of loops
i <- 0 #Initialize i
while(i < Inf) {
if (i == 10) {
break
} # Break out of the while loop!
else {
cat("i equals " , i , " \n")
i <- i + 1 # Update i
}
}
#using next
for (i in 1:10) {
if ((i %% 2) == 0) # check if the number is odd
next # pass to next iteration of loop
print(i)
}
source("boilerplate.R")
ls
ls()
class(MyFunction())
class(MyFunction)
source(R_conditionals.R)
source(R_Conditionals.R)
getwd()
source(R_Conditionals.R)
source("R_Conditionals.R")
?all
View(is.prime)
View(is.prime)
View(is.prime)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
print(paste("Tree height is:", height))
return (height)
}
TreeHeight(37, 40)
source("TreeHeight.R")
open("..Data/trees.csv")
read.csv("../Data/trees.csv")
trees <- read.csv("../Data/trees.csv")
View(trees)
degrees <- trees$Angle.degrees
distance <- trees$Distance.m
typeof(degrees)
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
print(paste("Tree height is:", height))
return (height)
}
TreeHeight(37, 40)
TreeHeight(degrees, distance)
TreeHeight(41.28264, 31.66583)
heights <- as.data.frame(TreeHeight(degrees, distance))
View(heights)
?write.csv
heights <- write.csv(TreeHeight(degrees, distance), "../Results/TreeHts.csv")
colnames(heights) <- "Tree.n", "Height"
?colnames
colnames(heights) <- Tree.n, Height
colnames(heights) <- Tree.n Height
`colnames<-`(heights)
?write.csv
heights <- write.csv(TreeHeight(degrees, distance), "../Results/TreeHts.csv", ow.names = TRUE, col.names = "Heights")
heights <- write.csv(TreeHeight(degrees, distance), "../Results/TreeHts.csv", ow.names = TRUE, col.names = Heights)
heights <- write.csv(TreeHeight(degrees, distance), "../Results/TreeHts.csv")
heights <- TreeHeight(degrees, distance)
write.csv(heights, "../Results/TreeHts.csv")
heights.csv <- write.csv(heights, "../Results/TreeHts.csv")
TreeHts <- data.frame(species, distance, degrees, heights)
View(TreeHts)
View(TreeHts)
trees <- read.csv("../Data/trees.csv")
species <- trees$Species
print(species)
degrees <- trees$Angle.degrees
distance <- trees$Distance.m
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
print(paste("Tree height is:", height))
return (height)
}
heights <- TreeHeight(degrees, distance)
heights <- TreeHeight(degrees, distance)
heights <- TreeHeight(degrees, distance)
TreeHts <- data.frame(species, distance, degrees, heights)
write.csv(TreeHts, "../Results/TreeHts.csv")
View(TreeHts)
trees <- read.csv("../Data/trees.csv")
TreeHeight <- function(degrees, distance){
radians <- degrees * pi / 180
height <- distance * tan(radians)
#print(paste("Tree height is:", height))
return (height)
}
heights <- TreeHeight(trees$Angle.degrees, trees$Distance.m)
TreeHts <- data.frame(trees, heights)
View(TreeHts)
TreeHts <- data.frame(trees, Heights.m)
write.csv(TreeHts, "../Results/TreeHts.csv")
Heights.m <- TreeHeight(trees$Angle.degrees, trees$Distance.m)
TreeHts <- data.frame(trees, Heights.m)
write.csv(TreeHts, "../Results/TreeHts.csv")
View(TreeHts)
source("TreeHeight.R")
View(TreeHts)
?runif
M <- matrix(runif(1000000),1000,1000)
SumAllElements <- function(M){
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
print(Dimensions)
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
NoPreallocFun <- function(x){
a <- vector() # empty vector
for (i in 1:x) {
a <- c(a, i)
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
system.time(a<-1:10)
#Preallocation
PreallocFun <- function(x){
a <- rep(NA, x) # pre-allocated vector
for (i in 1:x) {
a[i] <- i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)
View(M)
?apply
SomeOperation <- function(v){ # (What does this function do?)
if (sum(v) > 0){ #note that sum(v) is a single (scalar) value
return (v * 100)
}
return (v)
}
M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
Mapply<-apply(M, 1, SomeOperation))
Mapply <- apply(M, 1, SomeOperation))
Mapply <- apply(M, 1, SomeOperation)
View(Mapply)
sum(5)
sum(5.5)
isTRUE(sum(5)>0)
isTRUE(sum(-1.0598776)>0)
sum(-1.0598776)
M <- matrix(rnorm(100), 10, 10)
Mapply <- apply(M, 1, SomeOperation)
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n){
pop_sample <- sample(popn, n, replace = FALSE)
return (mean(pop_sample))
}
## Calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num){
result1 <- vector() #Initialize empty vector of size 1
for(i in 1:num){
result1 <- c(result1, myexperiment(popn, n))
}
return(result1)
}
## To run "num" iterations of the experiment using a for loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
result2 <- vector(,num) #Preallocate expected size
for(i in 1:num){
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
## To run "num" iterations of the experiment using a for loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
result3 <- vector("list", num) #Preallocate expected size
for(i in 1:num){
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with lapply:
sapply_sample <- function(popn, n, num){
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
popn <- rnorm(1000) # Generate the population
hist(popn)
source("sample.R")
x <- 1:20 # a vector
x
y <- factor(rep(letters[1:5], each = 4))
y
tapply(x, y, sum)
attach(iris)
iris
by(iris[,1:2], iris$Species, colMeans)
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
# Runs a simulation of the Ricker model
# Returns a vector of length generations
N <- rep(NA, generations)    # Creates a vector of NA
N[1] <- N0
for (t in 2:generations)
{
N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
}
return (N)
}
plot(Ricker(generations=10), type="l")
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)){#loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr,pop] <- N[yr-1,pop] * exp(r * (1 - N[yr - 1,pop] / K) + rnorm(1,0,sigma))
}
}
return(N)
}
# Now write another function called stochrickvect that vectorizes the above
# print("Vectorized Stochastic Ricker takes:")
p0
print(p0)
p0=runif(1000,.5,1.5)
View(p0)
rm(list=ls())
stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
#initialize
N<-matrix(NA,numyears,length(p0))
N[1,]<-p0
for (pop in 1:length(p0)){#loop through the populations
for (yr in 2:numyears){ #for each pop, loop through the years
N[yr,pop] <- N[yr-1,pop] * exp(r * (1 - N[yr - 1,pop] / K) + rnorm(1,0,sigma))
}
}
return(N)
}
