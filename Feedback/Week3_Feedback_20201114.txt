Starting code feedback for Amisha Suraj, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 6.68 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week3, .git, CMEEMiniproject, Feedback, Week1, Week2

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
*.Rhistory
*.RData

**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:

**********************************************************************
This is a repository for my CMEECourseWork. It contains all the work we do per week.


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Data, Code, Results

Found the following files: README.txt

Checking for readme file in weekly directory...

Found README in parent directory, named: README.txt

Printing contents of README.txt:

**********************************************************************
Week3
├── Code
│   ├── apply1.R - examples of using apply by rows
│   ├── apply2.R - defining a function and using apply with it
│   ├── basic_io.R - examples on how to write files
│   ├── boilerplate.R -example R script with a defined function and a couple tests
│   ├── break.R - exmples on how to break out of loops using break and next
│   ├── browse.R - a debugging example
│   ├── control_flow.R - example conditional and alternative statements
│   ├── DataWrang.R - wrangling a dataset, DEPENDENCY: tidyverse
│   ├── DataWrangTidy.R - writing DataWrang.R with tidyverse commands DEPENDENCY: tidyverse
│   ├── Girko.R - overlaying in a plot DEPENDENCY: ggplot2
│   ├── GPDD_Data.R - playing with mapping on R DEPENDENCY: maps
│   ├── MyBars.R - annotating a plot DEPENDENCY: ggplot2
│   ├── plotLin.R - plotting a linear regression DEPENDENCY: ggplot2
│   ├── PP_Dists.R - create plots for subsets of data DEPENDENCY tidyverse
│   ├── PP_Regress.R - running linear models on subsets containing data for combinations of categorical variables DEPENDENCY: ggplot2
│   ├── preallocate.R - examples of speed with preallocation of vectors
│   ├── R_Conditionals.R - getting to know conditional statements in R
│   ├── Ricker.R - Ricker model example
│   ├── sample.R - examples of functions and their speed using either loops or vectorization
│   ├── SQLinR.R - an example of accessing, updating and managing a database DEPENDENCY: sqldf
│   ├── TreeHeight.R - calculating tree heights by defining a function and then appending a column of results to the original set of data
│   ├── try.R - examples of using try
│   ├── Vectorize1.R - speed of loops vs vectorized function
│   └── Vectorize2.R - vectorizing the stochastic Ricker model
├── Data
│   ├── EcolArchives-E089-51-D1.csv
│   ├── GPDDFiltered.RData
│   ├── PoundHillData.csv
│   ├── PoundHillMetaData.csv
│   ├── Resource.csv
│   ├── Results.txt
│   └── trees.csv
├── Results
└── README.txt

**********************************************************************

Results directory is empty - good! 

Found 23 code files: TreeHeight.R, browse.R, preallocate.R, plotLin.R, PP_Dists.R, try.R, Vectorize2.R, boilerplate.R, apply1.R, PP_Regress.R, MyBars.R, DataWrang.R, control_flow.R, Vectorize1.R, SQLinR.R, sample.R, apply2.R, Ricker.R, break.R, Girko.R, R_Conditionals.R, GPDD_Data.R, basic_io.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

trees <- read.csv("../Data/trees.csv")

TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  #print(paste("Tree height is:", height))
  return (height)
}

Tree.Height.m <- TreeHeight(trees$Angle.degrees, trees$Distance.m)
TreeHts <- data.frame(trees, Tree.Height.m)
write.csv(TreeHts, "../Results/TreeHts.csv")

print("Done. Your output file is in the Results directory as TreeHts.csv.")
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Done. Your output file is in the Results directory as TreeHts.csv."

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.17724s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.22688s

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
print("No preallocation")
NoPreallocFun <- function(x){
  a <- vector() # empty vector
  for (i in 1:x) {
    a <- c(a, i)
    print(a)
    print(object.size(a))
  }
}

t<-system.time(NoPreallocFun(10))
print(t)
system.time(a<-1:10)

print("Preallocation")
PreallocFun <- function(x){
  a <- rep(NA, x) # pre-allocated vector
  for (i in 1:x) {
    a[i] <- i
    print(a)
    print(object.size(a))
  }
}

g<-system.time(PreallocFun(10))
print(g)
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "No preallocation"
[1] 1
56 bytes
[1] 1 2
56 bytes
[1] 1 2 3
64 bytes
[1] 1 2 3 4
64 bytes
[1] 1 2 3 4 5
80 bytes
[1] 1 2 3 4 5 6
80 bytes
[1] 1 2 3 4 5 6 7
80 bytes
[1] 1 2 3 4 5 6 7 8
80 bytes
[1] 1 2 3 4 5 6 7 8 9
96 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
96 bytes
   user  system elapsed 
  0.022   0.000   0.022 
   user  system elapsed 
      0       0       0 
[1] "Preallocation"
 [1]  1 NA NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3 NA NA
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.28522s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
#dependencies
require(ggplot2)

#create some data
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

#write pdf
pdf("../Results/MyLinReg.pdf")

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

print(p)

#close pdf
graphics.off()

**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
require(tidyverse)

#read and explore data
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")
str(MyDF)
MyDF$Type.of.feeding.interaction <- as.factor(MyDF$Type.of.feeding.interaction)
levels(MyDF$Type.of.feeding.interaction)

#subset per level of feeding interaction
pred.pisc<-subset(MyDF, Type.of.feeding.interaction=="predacious/piscivorous")
pisc<-subset(MyDF, Type.of.feeding.interaction=="piscivorous")
pred<-subset(MyDF, Type.of.feeding.interaction=="predacious")
plank<-subset(MyDF, Type.of.feeding.interaction=="planktivorous")
insec<-subset(MyDF, Type.of.feeding.interaction=="insectivorous")

#work on Predators
pdf("../Results/Pred_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
hist(log(pred.pisc$Predator.mass), xlab = "log of Predator Mass", main="Predacious / piscivorous")
hist(log(pred$Predator.mass), xlab = "log of Predator Mass", main="Predacious")
hist(log(pisc$Predator.mass), xlab = "log of Predator Mass", main="Piscivorous")
hist(log(plank$Predator.mass), xlab = "log of Predator Mass", main="Planktivorous")
hist(log(insec$Predator.mass), xlab = "log of Predator Mass", main="Insectivorous")
graphics.off()

#work on Prey
pdf("../Results/Prey_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
hist(log(pred.pisc$Prey.mass), xlab = "log of Prey Mass", main="Predacious / piscivorous")
hist(log(pred$Prey.mass), xlab = "log of Prey Mass", main="Predacious")
hist(log(pisc$Prey.mass), xlab = "log of Prey Mass", main="Piscivorous")
hist(log(plank$Prey.mass), xlab = "log of Prey Mass", main="Planktivorous")
hist(log(insec$Prey.mass), xlab = "log of Prey Mass", main="Insectivorous")
graphics.off()

#work on SizeRatio
pdf("../Results/SizeRatio_Subplots.pdf", 11.7, 8.3)
par(mfrow=c(3,2))
hist(log(pred.pisc$Predator.mass/pred.pisc$Prey.mass), xlab = "Size ratio (pred/prey)", main="Predacious / piscivorous")
hist(log(pred$Predator.mass/pred$Prey.mass), xlab = "Size ratio (pred/prey)", main="Predacious")
hist(log(pisc$Predator.mass/pisc$Prey.mass), xlab = "Size ratio (pred/prey)", main="Piscivorous")
hist(log(plank$Predator.mass/plank$Prey.mass), xlab = "Size ratio (pred/prey)", main="Planktivorous")
hist(log(insec$Predator.mass/insec$Prey.mass), xlab = "Size ratio (pred/prey)", main="Insectivorous")
graphics.off()

# pp_results.csv
Results <- MyDF %>%
  group_by(Type.of.feeding.interaction) %>%
  summarise(mean(log(Predator.mass)),
            median(log(Predator.mass)),
            mean(log(Prey.mass)),
            median(log(Prey.mass)),
            mean(log(Prey.mass/Predator.mass)),
            median(log(Prey.mass/Predator.mass)))

# name the columns
names(Results) <- c("Type.of.feeding.interaction",
                  "Mean_log.predator.mass",
                  "Median_log.predator.mass",
                  "Mean_log.prey.mass",
                  "Median_log.prey.mass",
                  "Mean_log.size.ratio",
                  "Median_log.size.ratio")
# write to csv
write.csv(Results, "../Results/PP_Results.csv")
**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************
'data.frame':	34931 obs. of  15 variables:
 $ Record.number              : int  1 2 3 4 5 6 7 8 9 10 ...
 $ In.refID                   : chr  "ATSH063" "ATSH080" "ATSH089" "ATSH143" ...
 $ IndividualID               : chr  "1" "2" "3" "4" ...
 $ Predator                   : chr  "Rhizoprionodon terraenovae" "Rhizoprionodon terraenovae" "Rhizoprionodon terraenovae" "Rhizoprionodon terraenovae" ...
 $ Predator.common.name       : chr  "Atlantic sharpnose shark" "Atlantic sharpnose shark" "Atlantic 
**********************************************************************

Encountered error or warning:
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
`summarise()` ungrouping output (override with `.groups` argument)

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
doit <- function(x){
  temp_x <- sample(x, replace = TRUE)
  if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(temp_x))))
  } 
  else {
    stop("Couldn't calculate mean: too few unique values!")
  }
}

popn <- rnorm(50)
hist(popn)

#result <- lapply(1:15, function(i) try(doit(popn), silent = TRUE))

result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
  result[[i]] <- try(doit(popn), FALSE)
}

**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.213760838161761"
[1] "Mean of this sample was: -0.400028356659999"
[1] "Mean of this sample was: -0.426648466873621"
[1] "Mean of this sample was: -0.324853007161611"
[1] "Mean of this sample was: -0.260852216357715"
[1] "Mean of this sample was: -0.231340047023134"
[1] "Mean of this sample was: -0.331794204092521"
[1] "Mean of this sample was: -0.28901269091872"
[1] "Mean of this sample was: -0.366464446596336"

**********************************************************************

Encountered error or warning:
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list=ls())

stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) {
  
   #initialize
  M<-matrix(NA,numyears,length(p0))
  M[1,]<-p0
  
  for (pop in 1:length(p0)){ #loop through the populations
    
    for (yr in 2:numyears){ #for each pop, loop through the years

      M[yr,pop] <- M[yr-1,pop] * exp(r * (1 - M[yr - 1,pop] / K) + rnorm(1,0,sigma))
    
    }
  
  }
 return(M)

}

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

stochrickvect <- function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100) {
  
#initialise
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  for (yr in 2:numyears) {
  
  N[yr,] <- N[yr-1,] * exp(r * (1 - N[yr-1,] / K) + rnorm(1,0,sigma))
  #N[3, pop] <- N[2, pop] * exp(r * (1 - N[2, pop] / K) + rnorm(1,0,sigma))
  
  }

  return(N)
  
}

#check if they look OK
#plot(N[,1], type="l", col="red")
#lines(M[,1], type="l", col="blue")

print("Stochastic Ricker takes:")
print(system.time(res2<-stochrick()))

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Stochastic Ricker takes:"
   user  system elapsed 
  0.261   0.023   0.285 
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.012   0.000   0.012 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.52461s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2){
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
  
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18177s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.21781105  0.58769686  0.25631194 -0.31226256 -0.35179399  0.17261537
 [7]  0.46816010  0.66465131  0.19167195  0.02209015
 [1] 1.0492035 1.0641887 1.2296171 0.7178117 0.8862651 0.9594982 0.7635571
 [8] 0.8539949 0.5352709 0.6576314
 [1]  0.69078983  0.10031199 -0.07989969  0.24485274  0.61140053 -0.11458281
 [7]  0.25759582  0.02107947  0.51536476 -0.32996045

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18959s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
#dependencies
require(ggplot2)

#read data
df <- read.csv("../Data/EcolArchives-E089-51-D1.csv")

#plot and save plot
pdf("../Results/PP_plot.pdf")
p <- ggplot(df, aes(log(Prey.mass), log(Predator.mass), colour = Predator.lifestage)) +
      geom_point(shape=I(3)) +
      geom_smooth(method = "lm", fullrange=TRUE ) +
      facet_wrap(ncol = 1, Type.of.feeding.interaction ~., strip.position="right", scales = "fixed", dir="h") +
      labs(colour = "Predator.lifestage", x="Prey Mass in grams", y="Predator Mass in grams") +
      theme(legend.position="bottom") +
      guides(colour = guide_legend(nrow = 1)) +
      coord_fixed(ratio = 1/5)

p

print(p)

graphics.off()

print("Saved your plot in the Results directory as: PP_plot.pdf")

#stats and building the table
stats <- matrix(nrow = 18, ncol = 6)
colnames(stats) <- c("Interaction.Lifestage.Combination", "Intercept", "Slope", "R2", "F.statistic", "p.value") 

#name empty vectors to be filled within the for loops
rnames <- c()
slopes <- c()
intercepts <- c()
R2 <- c()
#F.stats <- c()
#p.values <- c()

#foor loops subsetting every combination of interaction and lifestage and running an lm
for (interac in unique(df$Type.of.feeding.interaction)) {
    z <- subset(df, df$Type.of.feeding.interaction==interac)
    z <- na.omit(z)
    for (lifestage in unique(z$Predator.lifestage)) {
      y <- subset(z, z$Predator.lifestage==lifestage)
      j <- lm(log(Predator.mass)~log(Prey.mass), data = y)
      i <- summary(j)
      
      #appending coefficients to the empty vectors
      rnames <- c(rnames, paste(interac, "_", lifestage, sep=""))
      slopes <- c(slopes, i[["coefficients"]][[2]])
      intercepts <- c(intercepts, i[["coefficients"]][[1]])
      R2 <- c(R2, i[["r.squared"]])
      #F.stats <- c(F.stats, i[["fstatistic"]][[1]]) #fails in last loop
      #p.values <- c(p.values, i[["coefficients"]][[8]]) #fails in 5th loop
   
    }
}

#assigning the now filled vectors to columns in the matrix
stats[,1] <- rnames
stats[,2] <- intercepts
stats[,3] <- slopes
stats[,4] <- R2
#stats[,5] <- F.stats
#stats[,6] <- p.values

#writing the results file
write.csv(stats, file = "../Results/PP_Regress_Results.csv")

print("Saved your regression coefficients in your Results directory as PP_Regress_Results.csv")
**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Saved your plot in the Results directory as: PP_plot.pdf"
[1] "Saved your regression coefficients in your Results directory as PP_Regress_Results.csv"

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
#dependencies
require(ggplot2)

#read and explore file
a <- read.table("../Data/Results.txt", header = TRUE)

# append a column of zeros
a$ymin <- rep(0, dim(a)[1]) 

#write pdf
pdf("../Results/MyBars.pdf")

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 

print(p)

#output pdf
graphics.off()

**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
colnames(MyData) #there's no column names, just "data"
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
head(TempData)
rownames(TempData) <- NULL #get rid of row names
head(TempData)

############# Convert from wide to long format  ###############
require(reshape2)

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data ###############
require(tidyverse)
tibble::as_tibble(MyWrangledData) # convert to a tiblle, which is like a data frame but more manipulatable
dplyr::glimpse(MyWrangledData) #like str(), but nicer!
utils::View(MyWrangledData) #same as fix() or View()
dplyr::filter(MyWrangledData, Count>100) #like subset(), but nicer!
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: reshape2
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
#if statements
a <- TRUE
if (a == TRUE){
  print ("a is TRUE")
} else {
  print ("a is FALSE")
}

z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

#for loops
for (i in 1:10){
  j <- i * i
  print(paste(i, " squared is", j ))
}

for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')){
  print(paste('The species is', species))
}

v1 <- c("a","bc","def")
for (i in v1){
  print(i)
}

#while loops
i <- 0
while (i < 10){
  i <- i+1
  print(i^2)
}

**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.23522s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))

**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.093   0.001   0.094 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.002   0.000   0.001 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.36659s

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
#install the sqlite package
#install.packages('sqldf')

# Dependency
library(sqldf)


# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames



**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************
<SQLiteResult>
  SQL  CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)
  ROWS Fetched: 0 [complete]
       Changed: 0
<SQLiteResult>
  SQL  INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')
  ROWS Fetched: 0 [complete]
       Changed: 1
<SQLiteResult>
  SQL  INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')
  ROWS Fetched: 0 [complete]
       C
**********************************************************************

Encountered error or warning:
Loading required package: gsubfn
Loading required package: proto
Loading required package: RSQLite
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 
Warning message:
Closing open result set, pending rows 

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n){
  pop_sample <- sample(popn, n, replace = FALSE)
  return (mean(pop_sample))
}

## Calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num){
  result1 <- vector() #Initialize empty vector of size 1 
  for(i in 1:num){
    result1 <- c(result1, myexperiment(popn, n))
  }
  return(result1)
}

## To run "num" iterations of the experiment using a for loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
  result2 <- vector(,num) #Preallocate expected size
  for(i in 1:num){
    result2[i] <- myexperiment(popn, n)
  }
  return(result2)
}

## To run "num" iterations of the experiment using a for loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
  result3 <- vector("list", num) #Preallocate expected size
  for(i in 1:num){
    result3[[i]] <- myexperiment(popn, n)
  }
  return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
  result4 <- lapply(1:num, function(i) myexperiment(popn, n))
  return(result4)
}

## To run "num" iterations of the experiment using vectorization with lapply:
sapply_sample <- function(popn, n, num){
  result5 <- sapply(1:num, function(i) myexperiment(popn, n))
  return(result5)
}

#Generate a population
popn <- rnorm(1000)
hist(popn)

#Run and timing of all functions
n <- 20 # sample size for each experiment
num <- 1000 # Number of times to rerun the experiment

print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample1(popn, n, num)))

print("The loopy, but with preallocation approach takes:" )
print(system.time(loopy_sample2(popn, n, num)))

print("The loopy, non-preallocation approach on a list takes:" )
print(system.time(loopy_sample3(popn, n, num)))

print("The vectorized sapply approach takes:" )
print(system.time(sapply_sample(popn, n, num)))

print("The vectorized lapply approach takes:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.037   0.008   0.045 
[1] "The loopy, but with preallocation approach takes:"
   user  system elapsed 
  0.018   0.000   0.018 
[1] "The loopy, non-preallocation approach on a list takes:"
   user  system elapsed 
  0.016   0.000   0.016 
[1] "The vectorized sapply approach takes:"
   user  system elapsed 
  0.013   0.000   0.013 
[1] "The vectorized lapply approach takes:"
   user  system elapsed 
  0.021   0.000   0.
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.51125s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
SomeOperation <- function(v){ # if sum of v is positive multiply by 100
  if (sum(v) > 0){ #note that sum(v) is a single (scalar) value
    return (v * 100)
  }
  return (v)
}

M <- matrix(rnorm(100), 10, 10)
Mapply <- apply(M, 1, SomeOperation)

**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.23491s

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")

**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.22916s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
#breaking out of loops
i <- 0 #Initialize i
while(i < Inf) {
  if (i == 10) {
    break 
  } # Break out of the while loop! 
  else { 
    cat("i equals " , i , " \n")
    i <- i + 1 # Update i
  }
}

#using next
for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next # pass to next iteration of loop 
  print(i)
}

**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.19301s

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
#dependencies
require(ggplot2)

#function to calculate ellipse
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns

#write pdf
pdf("../Results/Girko.pdf", 11.7, 8.3)

# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p

#output pdf
graphics.off()

**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2

======================================================================
Inspecting script file R_Conditionals.R...

File contents are:

**********************************************************************
# Functions with conditionals
# Checks if an integer is even
is.even <- function(n = 2){
  if (n %% 2 == 0)
  {
    return(paste(n,'is even!'))
  } 
  return(paste(n,'is odd!'))
}

print(is.even(6))

# Checks if a number is a power of 2
is.power2 <- function(n = 2){
  if (log2(n) %% 1==0)
  {
    return(paste(n, 'is a power of 2!'))
  } 
  return(paste(n,'is not a power of 2!'))
}

print(is.power2(4))

# Checks if a number is prime
is.prime <- function(n){
  if (n==0){
    return(paste(n,'is a zero!'))
  }
  if (n==1){
    return(paste(n,'is just a unit!'))
  }
  ints <- 2:(n-1)
  if (all(n%%ints!=0)){
    return(paste(n,'is a prime!'))
  } 
  return(paste(n,'is a composite!'))
}

print(is.prime(3))
**********************************************************************

Testing R_Conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.16474s

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
#dependency
require(maps)

#load data
load("../Data/GPDDFiltered.RData")

#worldview using maps
map(database = "world", fill = TRUE, col = "grey", 
         bg = "white", border = "black",) #load world map

points(x = gpdd$long, y = gpdd$lat, col = "orange", 
       pch = 16, cex = 0.7) #superimpose points

#western view - zoom into north america and europe
#map(database = "world", fill = TRUE, col = "forestgreen", bg = "lightblue",
    #border = "darkgreen", xlim = c(-150,50), ylim = c(20,90))
#points(x = gpdd$long, y = gpdd$lat, col = gpdd$common.name, pch = 16, cex = 0.9)

#################
#### Biases ####
################

# Most of the data represented on the world map is for North America and
# Northern Europe, with an exception in South Africa and another in Japan.
# This means that any analyses conducted on this set of data would not be
# representative of a world sample.
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: maps

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../Results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../Results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../Results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../Results/MyData.csv", col.names=FALSE) # ignore column names

**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Warning message:
In write.table(MyData[1, ], file = "../Results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
======================================================================
Finished running scripts

Ran into 10 errors or warnings

Total time used: 24.35s 

======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!